//go:build wasi || wasm

package wasm

import (
	"syscall/js"
	"time"

	"github.com/sirgwain/craig-stars/cs"
)

func GetInt[T ~uint | ~uint32 | ~uint64 | ~int | ~int32 | ~int64](o js.Value, key string) T {
	var result T
	val := o.Get(key)
	if !val.IsUndefined() {
		result = T(val.Int())
	}
	return result
}

func GetIntArray[T ~uint | ~uint32 | ~uint64 | ~int | ~int32 | ~int64](o js.Value, key string) []T {
	items := make([]T, o.Length())
	for i := 0; i < len(items); i++ {
		items[i] = T(o.Index(i).Int())
	}
	return items

}

func GetBool(o js.Value, key string) bool {
	var result bool
	val := o.Get(key)
	if !val.IsUndefined() {
		result = val.Bool()
	}
	return result
}

func GetString(o js.Value, key string) string {
	var result string
	val := o.Get(key)
	if !val.IsUndefined() {
		result = val.String()
	}
	return result
}

func GetTime(o js.Value, key string) (time.Time, error) {
	var result time.Time
	val := o.Get(key)
	if !val.IsUndefined() {
		// time assumes json string has quotes
		if err := result.UnmarshalJSON([]byte("\"" + val.String() + "\"")); err != nil {
			return result, err
		}
	}
	return result, nil

}
{{- /* Create Get functions for each of our serializer types */}}
{{- range .Serializers}}

func Get{{.Name}}(o js.Value) {{$.Pkg}}.{{.Name}} {
	obj := {{$.Pkg}}.{{.Name}}{}
{{- range .Fields}}
{{- if .Ignore }}
{{- continue }}
{{- end }}
{{- if and .Basic .PackageType }}
{{- /* basic types that are in our packet are enums, cast them */}}
	{{- if eq .JSType JSString }}
	obj.{{.Name}} = {{$.Pkg}}.{{.ObjectType}}(GetString(o, "{{.JsonName}}"))
	{{- else if eq .JSType JSBool }}
	obj.{{.Name}} = {{$.Pkg}}.{{.ObjectType}}(GetBool(o, "{{.JsonName}}"))
	{{- else if eq .JSType JSInt }}
	obj.{{.Name}} = {{$.Pkg}}.{{.ObjectType}}(GetInt[{{.BasicType}}](o, "{{.JsonName}}"))
	{{- end}}
{{- else if and .PackageType (not .Basic) }}
{{- /* package types that aren't basic types need to call the getter for that type */}}
	{{- if eq .JsonName "" }}
	obj.{{.Name}} = Get{{ .ObjectType }}(o)
	{{- else if eq .JSType JSArray }}
	{{- if .Pointer }}
	obj.{{.Name}} = Get{{ .ObjectType }}PointerArray(o.Get("{{.JsonName}}"))
	{{- else }}
	obj.{{.Name}} = Get{{ .ObjectType }}Array(o.Get("{{.JsonName}}"))
	{{- end }}
	{{- else }}
	{{- if .Pointer }}
	{{ .JsonName }} := Get{{ .ObjectType }}(o.Get("{{.JsonName}}"))
	obj.{{.Name}} = &{{ .JsonName }}
	{{- else }}
	obj.{{.Name}} = Get{{ .ObjectType }}(o.Get("{{.JsonName}}"))
	{{- end }}
	{{- end}}
{{- else if .Map }}
{{- /* maps are weird. We have to get the Object.Keys from the js object, then set each key as a type */}}
	{{.JsonName}} := make(map[{{.MapKeyType}}]{{.MapValueType}})
	{{.JsonName}}Obj := o.Get("{{.JsonName}}")
	{{.JsonName}}Keys := js.Global().Get("Object").Call("keys", {{.JsonName}}Obj)
	for i := 0; i < {{.JsonName}}Keys.Length(); i++ {
		key := {{.JsonName}}Keys.Index(i).String()
		{{- if eq .MapValueJSType JSString }}
		{{.JsonName}}[key] = GetString({{.JsonName}}Obj, key)
		{{- else if eq .MapValueJSType JSBool }}
		{{.JsonName}}[key] = GetBool({{.JsonName}}Obj, key)
		{{- else if eq .MapValueJSType JSInt }}
		{{.JsonName}}[key] = GetInt[{{.MapValueType}}]({{.JsonName}}Obj, key)
		{{- end }}
	}
	obj.{{.Name}} = {{.JsonName}}
{{- else }}
{{- /* If we got here it's a basic type that isn't in the package, or a map */}}
	{{- if eq .JSType JSString }}
	obj.{{.Name}} = GetString(o, "{{.JsonName}}")
	{{- else if eq .JSType JSBool }}
	obj.{{.Name}} = GetBool(o, "{{.JsonName}}")
	{{- else if eq .JSType JSInt }}
	obj.{{.Name}} = GetInt[{{.ObjectType}}](o, "{{.JsonName}}")
	{{- else if eq .JSType JSTime }}	
	obj.{{.Name}}, _ = GetTime(o, "{{.JsonName}}")
	{{- end }}
{{- end }}
{{- end }}
	return obj
}

func Get{{.Name}}Array(o js.Value) []{{$.Pkg}}.{{.Name}} {
	if o.IsUndefined() || o.IsNull() {
		return nil
	}

	items := make([]{{$.Pkg}}.{{.Name}}, o.Length())	
	for i := 0; i < len(items); i++ {
		items[i] = Get{{.Name}}(o.Index(i))
	}
	return items
}

func Get{{.Name}}PointerArray(o js.Value) []*{{$.Pkg}}.{{.Name}} {
	if o.IsUndefined() || o.IsNull() {
		return nil
	}

	items := make([]*{{$.Pkg}}.{{.Name}}, o.Length())
	for i := 0; i < len(items); i++ {
		item := Get{{.Name}}(o.Index(i))
		items[i] = &item
	}
	return items
}

{{- end}}

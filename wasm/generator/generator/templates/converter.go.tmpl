//go:build wasi || wasm
// Code generated by github.com/sirgwain/craig-stars/wasm/generator, DO NOT EDIT.
package wasm

import (
	"fmt"
	"strconv"
	"syscall/js"
	"time"

	"github.com/sirgwain/craig-stars/cs"
)

func getPointer[T any](val T) *T {
	return &val
}

func getInt[T ~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64 | ~int | ~int8 | ~int16 | ~int32 | ~int64](o js.Value) T {
	if o.IsUndefined() || o.IsNull() {
		return 0
	}

	return T(o.Int())
}

func getFloat[T ~float32 | ~float64](o js.Value) T {
	if o.IsUndefined() || o.IsNull() {
		return 0
	}

	return T(o.Float())
}

func getBool(o js.Value) bool {
	if o.IsUndefined() || o.IsNull() {
		return false
	}
	return o.Bool()
}

func getString(o js.Value) string {
	if o.IsUndefined() || o.IsNull() {
		return ""
	}
	return o.String()
}

func getTime(o js.Value) time.Time {
	var result time.Time
	if o.IsUndefined() || o.IsNull() {
		return result
	}
	// time assumes json string has quotes
	result.UnmarshalJSON([]byte("\"" + o.String() + "\""))
	return result
}

func SetTime(o js.Value, key string, time time.Time) {
    json, _ := time.MarshalJSON()
    o.Set(key, string(json))
}

// GetSlice populates an array with a getter function
func GetSlice[T any](o js.Value, getter func(o js.Value) T) []T {
	if o.IsUndefined() || o.IsNull() {
		return nil
	}

	items := make([]T, o.Length())
	for i := 0; i < len(items); i++ {
		items[i] = getter(o.Index(i))
	}
	return items
}

// SetBasicSlice sets a jsarray with basic items
func SetBasicSlice[T ~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64 | ~int | ~int8 | ~int16 | ~int32 | ~int64 | ~string | ~bool | ~float32 | ~float64](o js.Value, items []T) {
	for i := 0; i < len(items); i++ {
		o.SetIndex(i, js.ValueOf(items[i]))
	}
}

// SetSlice sets a jsarray with items using a setter function
func SetSlice[T any](o js.Value, items []T, setter func(o js.Value, item *T)) {

	for i := 0; i < len(items); i++ {
        oItem := js.ValueOf(map[string]any{})
        setter(oItem, &items[i])
		o.SetIndex(i, oItem)
	}
}

// GetSlice populates an array with a getter function
func GetPointerSlice[T any](o js.Value, getter func(o js.Value) T) []*T {
	if o.IsUndefined() || o.IsNull() {
		return nil
	}

	items := make([]*T, o.Length())
	for i := 0; i < len(items); i++ {
		items[i] = getPointer(getter(o.Index(i)))
	}
	return items
}

// SetPointerSlice sets a jsarray with pointer items using a setter function
func SetPointerSlice[T any](o js.Value, items []*T, setter func(o js.Value, item *T)) {

	for i := 0; i < len(items); i++ {
		oItem := js.ValueOf(map[string]any{})
		setter(oItem, items[i])
		o.SetIndex(i, oItem)
	}
}

// GetSliceSlice populates a 2d array
func GetSliceSlice[T any](o js.Value, getter func(o js.Value) T) [][]T {
	if o.IsUndefined() || o.IsNull() {
		return nil
	}

	items := make([][]T, o.Length())
	for i := 0; i < len(items); i++ {
		items[i] = GetSlice(o.Index(i), getter)
	}
	return items
}

// SetSliceSlice sets a 2d jsarray with items using a setter function
func SetSliceSlice[T any](o js.Value, items [][]T, setter func(o js.Value, item *T)) {

	for i := 0; i < len(items); i++ {
		oItem := js.ValueOf([]any{})
		SetSlice(oItem, items[i], setter)
		o.SetIndex(i, oItem)
	}
}

func GetIntMap[M ~map[K]V, K ~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64 | ~int | ~int8 | ~int16 | ~int32 | ~int64, V any](o js.Value, valueGetter func(o js.Value) V) M {
	result := make(M)
	if !o.IsUndefined() {
		resultKeys := js.Global().Get("Object").Call("keys", o)
		for i := 0; i < resultKeys.Length(); i++ {
			keyString := getString(resultKeys.Index(i))
			intConv, _ := strconv.Atoi(keyString)
			key := K(intConv)
			result[key] = valueGetter(o.Get(fmt.Sprintf("%v", keyString)))
		}
	}
	return result
}

func GetStringMap[M ~map[K]V, K ~string, V any](o js.Value, valueGetter func(o js.Value) V) M {
	result := make(M)
	if !o.IsUndefined() {
		resultKeys := js.Global().Get("Object").Call("keys", o)
		for i := 0; i < resultKeys.Length(); i++ {
			key := K(getString(resultKeys.Index(i)))
			result[key] = valueGetter(o.Get(fmt.Sprintf("%v", key)))
		}
	}
	return result
}

{{- /* 
	Render a function like 

	getInt[int](o.Get("grav")) 
*/}}
{{- define "GetBasicGetter" }}
	{{- $type := .type }}
	{{- if eq $type.Type "BasicString" }}
		getString
	{{- else if eq $type.Type "BasicBool" }}
		getBool
	{{- else if eq $type.Type "BasicInt" }}
		getInt
	{{- else if eq $type.Type "BasicFloat" }}
		getFloat
	{{- else }}
		unknownbasictype
	{{- end }}
{{- end }}

{{- /* 
	Render a function like 

	getInt[int](o.Get("grav")) 
*/}}
{{- define "GetBasic" }}
	{{- $type := .type }}
	{{- $goType := default $type.GoType .goType }}
	{{- $jsObj := default "o" .jsObj }}
	{{- if eq $type.Type "BasicString" }}
		{{- if ne $goType .TypeName }}
			{{$goType}}(getString({{$jsObj}}))
		{{- else }}
			getString({{$jsObj}})
		{{- end }}
	{{- else if eq $type.Type "BasicBool" }}
		getBool({{$jsObj}})
	{{- else if eq $type.Type "BasicInt" }}
		getInt[{{$goType}}]({{$jsObj}})
	{{- else if eq $type.Type "BasicFloat" }}
		getFloat[{{$goType}}]({{$jsObj}})
	{{- else }}
		unknownbasictype
	{{- end }}
{{- end }}

{{- define "GetSlice" }}
	{{- $type := .type }}
	{{- $valueType := $type.ValueType }}
	{{- $jsObj := default "o" .jsObj}}

	{{- if $valueType.Package }}
		{{- /* package slices come as slices to pointers or just slices or sometimes slices to slices... ugh */}}
		{{- if eq $valueType.Type "Slice" }}
			{{- /* slice slice */}}
			GetSliceSlice({{$jsObj}}, Get{{$valueType.TypeName}})
		{{- else if eq $valueType.Type "Object" }}
			{{- if $valueType.Pointer }}
				GetPointerSlice({{$jsObj}}, Get{{$valueType.TypeName}})
			{{- else }}
				GetSlice({{$jsObj}}, Get{{$valueType.TypeName}})
			{{- end }}
		{{- else if eq $valueType.Type "Named" }}
			GetSlice[{{$valueType.GoType}}]({{$jsObj}}, Get{{$valueType.TypeName}})
		{{- else }}
			unknownpackageslicetype_{{$valueType.TypeName}}_{{$valueType.GoType}}_{{$valueType.Type}}
		{{- end }}
	{{- else }}
		{{- if $valueType.IsBasic }}
			GetSlice[{{$valueType.GoType}}]({{$jsObj}}, {{ include "GetBasicGetter" (dict "type" $valueType) | trim}})
		{{- else }}
			unknownslicetype_{{$valueType.TypeName}}_{{$valueType.GoType}}_{{$valueType.Type}}
		{{- end }}
	{{- end }}
{{- end }}

{{- define "GetMap" }}
	{{- $type := .type }}
	{{- $keyType := default $type.KeyType .keyType }}
	{{- $valueType := default $type.ValueType .valueType }}
	{{- $jsObj := default "o" .jsObj}}
	{{- $valueGetter := printf "Get%s" $valueType.TypeName }}
	{{- $mapFunc := printf "GetStringMap" }}

	{{- if eq $keyType.Type "BasicInt"}}
		{{- $mapFunc = "GetIntMap"}}
	{{- end }}
	{{- if $keyType.UnderlyingType }}
		{{- if eq $keyType.UnderlyingType.Type "BasicInt" }}
			{{- $mapFunc = "GetIntMap"}}
		{{- end }}
	{{- end }}

	{{- if $valueType.IsBasic }}
		{{- $valueGetter = include "GetBasicGetter" (dict "type" $valueType) | trim }}
	{{- end }}

	{{- if $valueType.Pointer }}
		{{- $valueGetter = printf "func(o js.Value) %s { return getPointer(%s(o)) }" $valueType.GoType $valueGetter }}
	{{- end }}

	{{$mapFunc}}[{{$type.GoType}}]({{$jsObj}}, {{$valueGetter}})
{{- end }}

{{- define "SetObject" }}
	{{- if eq .JsonName "" }}
		Set{{.TypeName}}(o, &obj.{{.Name}})
	{{- else }}
		o.Set("{{.JsonName}}", map[string]any{})
		{{- if .Pointer }}
		Set{{.TypeName}}(o.Get("{{.JsonName}}"), obj.{{.Name}})
		{{- else }}
		Set{{.TypeName}}(o.Get("{{.JsonName}}"), &obj.{{.Name}})
		{{- end }}
	{{- end }}
{{- end }}

{{- define "SetNamedType" }}
	{{- if .UnderlyingType.IsBasic }}
		o.Set("{{.JsonName}}", {{.UnderlyingType.GoType}}(obj.{{.Name}}))
	{{- else if eq .UnderlyingType.Type "Map" }}
		{{- $context := dict "Name" .Name "JsonName" .JsonName "KeyType" .UnderlyingType.KeyType "ValueType" .UnderlyingType.ValueType  }}
		{{- include "SetMap" $context | trim }}
	{{- else }}
		// unknown named type {{.Name}} {{.GoType}} {{.UnderlyingType.GoType}}
	{{- end }}
{{- end }}

{{- define "SetSlice" }}
	{{- if .ValueType.Package }}
		{{- /* package slices come as slices to pointers or just slices or sometimes slices to slices... ugh */}}
		{{- if eq .ValueType.Type "Slice" }}
			{{- /* slice slice */}}
			o.Set("{{.JsonName}}", []any{})
			SetSliceSlice(o.Get("{{.JsonName}}"), obj.{{.Name}}, Set{{.ValueType.TypeName}})
		{{- else if eq .ValueType.Type "Object" }}
			o.Set("{{.JsonName}}", []any{})
			{{- if .ValueType.Pointer }}
				SetPointerSlice(o.Get("{{.JsonName}}"), obj.{{.Name}}, Set{{.ValueType.TypeName}})
			{{- else }}
				SetSlice(o.Get("{{.JsonName}}"), obj.{{.Name}}, Set{{.ValueType.TypeName}})
			{{- end }}
		{{- else if eq .ValueType.Type "Named" }}
			SetBasicSlice[{{.ValueType.GoType}}](o.Get("{{.JsonName}}"), obj.{{.Name}})
		{{- else }}
			// unknown package slice type {{.ValueType.TypeName}} {{.ValueType.GoType}} {{.ValueType.Type}}
		{{- end }}
	{{- else }}
		{{- if .ValueType.IsBasic }}
			o.Set("{{.JsonName}}", obj.{{.Name}})
		{{- else }}
			// unknown slice type {{.ValueType.Type}} {{.Name}} {{.JsonName}} {{.GoType}}
		{{- end }}
	{{- end }}
{{- end }}

{{- define "SetMap" }}
	{{- /* setting maps is easier, just create a new object and set each key */}}
	{{.JsonName}}Map := js.ValueOf(map[string]any{})
	for key, value := range obj.{{.Name}} {
	{{- if .ValueType.IsBasic }}
		{{.JsonName}}Map.Set(fmt.Sprintf("%v", key), value)
	{{- else if eq .ValueType.Type "Named" }}
		{{.JsonName}}Map.Set(fmt.Sprintf("%v", key), value)
	{{- else if eq .ValueType.Type "Object" }}
		valueObj := js.ValueOf(map[string]any{})
		{{- if .ValueType.Pointer }}
			Set{{.ValueType.TypeName}}(valueObj, value)
		{{- else }}
			Set{{.ValueType.TypeName}}(valueObj, &value)
		{{- end }}
		{{.JsonName}}Map.Set(fmt.Sprintf("%v", key), valueObj)
	{{- else }}
		// unknown map type {{.Name}} {{.Type}} {{.GoType}}
	{{- end }}
	}
	o.Set("{{.JsonName}}", {{.JsonName}}Map)
{{- end }}

{{- define "SetOtherType" }}
	{{- if eq .FullType "time.Time" }}
		SetTime(o, "{{.JsonName}}", obj.{{.Name}})
	{{- else }}
		// unknown other type {{.Name}} {{.GoType}}
	{{- end }}
{{- end }}

{{- /* 
	Render a function like 

	getInt[int](o.Get("grav")) 
	or 
	GetHab(o.Get("habLow")) 
*/}}
{{- define "GetValue" }}
	{{- $type := .type }}
	{{- $jsObj := default "o" .jsObj}}
	{{- if $type.IsBasic }}
		{{ include "GetBasic" . }}
	{{- else if eq $type.Type "Object" }}
		{{- if $type.Pointer }}
			getPointer(Get{{$type.TypeName}}({{$jsObj}}))
		{{- else }}
			Get{{$type.TypeName}}({{$jsObj}})
		{{- end }}
	{{- else if eq $type.Type "Slice" }}
		{{ include "GetSlice" . }}
	{{- else if eq $type.Type "Array" }}
		{{$type.GoType}}({{- include "GetSlice" . | trim}})
	{{- else if eq $type.Type "Map" }}
		{{ include "GetMap" . }}
	{{- else if eq $type.Type "Named" }}
		Get{{$type.TypeName}}({{$jsObj}})
	{{- else if eq $type.FullType "time.Time" }}
		getTime({{$jsObj}})
	{{- else  }}
		unknown // {{$type.GoType}}
	{{- end }}
{{- end }}

{{- /* Create Get functions for each of our serializer types */}}
{{- range .Serializers}}

func Get{{.Name}}(o js.Value) {{$.Pkg}}.{{.Name}} {
	var obj {{$.Pkg}}.{{.Name}}
	if o.IsUndefined() || o.IsNull() {
		return obj
	}
	{{- if eq .Type.Type "Object" }}
		{{- range .Fields}}
			{{- if .Ignore }}
				{{- if and .Exported (ne .JsonName "") }}
					// {{.Name}} {{.JsonName}} {{ .Type }} ignored
				{{- end }}
				{{- continue }}
			{{- end }}
		
			{{- /* for the js object, we do something like o.Get("habLow") for the jsObj */}}
			{{- $jsObj := "o" }}
			{{- if ne .JsonName "" }}
				{{- $jsObj = printf "o.Get(\"%s\")" .JsonName }}
			{{- end }}
			
			{{- /* the GetValue function expects two args, a type and a jsObj */}}
			{{- $context := dict "type" .FieldType "jsObj" $jsObj}}				
			obj.{{.Name}} = {{ include "GetValue" $context | trim }}
		{{- end }}
	{{- else if eq .Type.Type "Named" }}
		{{- if .Type.UnderlyingType.IsBasic }}
			{{- $context := dict "type" .Type.UnderlyingType "goType" .Type.GoType }}
			obj = {{ include "GetBasic" $context | trim }}
		{{- else if eq .Type.UnderlyingType.Type "Map" }}
			{{- $context := dict "type" .Type.UnderlyingType "goType" .Type.GoType }}
			obj = {{ include "GetMap" $context | trim }}
		{{- else }}
			// unknown named underlying type {{.Type.UnderlyingType.GoType}} {{.Type.UnderlyingType.Type}}
		{{- end }}
	{{- end }}
	return obj
}

{{- /* we don't create setter functions for named types, they don't really work */}}
{{- if eq .Type.Type "Object" }}
func Set{{.Name}}(o js.Value, obj *{{$.Pkg}}.{{.Name}}) {
	{{- range .Fields}}	
		{{- if .Ignore }}
			{{- if and .Exported (ne .JsonName "") }}
				// {{.Name}} {{.JsonName}} {{ .Type }} ignored
			{{- end }}
			{{- continue }}
		{{- end }}

		{{- if .Type.IsBasic }}
			{{- /* Basics are just a simple set */}}
			o.Set("{{.JsonName}}", obj.{{.Name}})
		{{- else if eq .Type "Object" }}
			{{- include "SetObject" . | trim | nindent 4 -}}
		{{- else if eq .Type "Named" }}
			{{- include "SetNamedType" . | trim | nindent 4 -}}
		{{- else if eq .Type "Slice" }}
			{{- include "SetSlice" . | trim | nindent 4 -}}
		{{- else if eq .Type "Array" }}
			{{- include "SetSlice" . | trim | nindent 4 -}}
		{{- else if eq .Type "Map" }}
			{{- include "SetMap" . | trim | nindent 4 -}}
		{{- else  }}
			{{- include "SetOtherType" . | trim | nindent 4 -}}
		{{- end }}
	{{- end }}
}
{{- end}}

{{- end}}


//go:build wasi || wasm

package wasm

import (
	"fmt"
	"strconv"
	"syscall/js"
	"time"

	"github.com/sirgwain/craig-stars/cs"
)

func GetInt[T ~uint | ~uint32 | ~uint64 | ~int | ~int32 | ~int64](o js.Value, key string) T {
	var result T
	val := o.Get(key)
	if !val.IsUndefined() {
		result = T(val.Int())
	}
	return result
}

func GetFloat[T ~float32 | ~float64](o js.Value, key string) T {
	var result T
	val := o.Get(key)
	if !val.IsUndefined() {
		result = T(val.Float())
	}
	return result
}

func GetIntArray[T ~uint | ~uint32 | ~uint64 | ~int | ~int32 | ~int64](o js.Value, key string) []T {
	val := o.Get(key)
	items := make([]T, val.Length())
	for i := 0; i < len(items); i++ {
		items[i] = T(val.Index(i).Int())
	}
	return items
}

func GetBool(o js.Value, key string) bool {
	var result bool
	val := o.Get(key)
	if !val.IsUndefined() {
		result = val.Bool()
	}
	return result
}

func GetString(o js.Value, key string) string {
	var result string
	val := o.Get(key)
	if !val.IsUndefined() {
		result = val.String()
	}
	return result
}

func GetTime(o js.Value, key string) (time.Time, error) {
	var result time.Time
	val := o.Get(key)
	if !val.IsUndefined() {
		// time assumes json string has quotes
		if err := result.UnmarshalJSON([]byte("\"" + val.String() + "\"")); err != nil {
			return result, err
		}
	}
	return result, nil
}

func SetTime(o js.Value, key string, time time.Time) {
    json, _ := time.MarshalJSON()
    o.Set(key, string(json))
}

// GetSlice populates an array with a getter function
func GetSlice[T any](o js.Value, getter func(o js.Value) T) []T {
	if o.IsUndefined() || o.IsNull() {
		return nil
	}

	items := make([]T, o.Length())
	for i := 0; i < len(items); i++ {
		items[i] = getter(o.Index(i))
	}
	return items
}

// SetSlice sets a jsarray with items using a setter function
func SetSlice[T any](o js.Value, items []T, setter func(o js.Value, item *T)) {

	for i := 0; i < len(items); i++ {
        oItem := js.ValueOf(map[string]any{})
        setter(oItem, &items[i])
		o.SetIndex(i, oItem)
	}
}

// SetPointerSlice sets a jsarray with pointer items using a setter function
func SetPointerSlice[T any](o js.Value, items []*T, setter func(o js.Value, item *T)) {

	for i := 0; i < len(items); i++ {
		oItem := js.ValueOf(map[string]any{})
		setter(oItem, items[i])
		o.SetIndex(i, oItem)
	}
}

// GetSliceSlice populates a 2d array
func GetSliceSlice[T any](o js.Value, getter func(o js.Value) T) [][]T {
	if o.IsUndefined() || o.IsNull() {
		return nil
	}

	items := make([][]T, o.Length())
	for i := 0; i < len(items); i++ {
		items[i] = GetSlice(o.Index(i), getter)
	}
	return items
}

// SetSliceSlice sets a 2d jsarray with items using a setter function
func SetSliceSlice[T any](o js.Value, items [][]T, setter func(o js.Value, item *T)) {

	for i := 0; i < len(items); i++ {
		oItem := js.ValueOf([]any{})
		SetSlice(oItem, items[i], setter)
		o.SetIndex(i, oItem)
	}
}

{{- define "GenGetBasic" }}
	{{- if eq .Type "BasicString" }}
		{{.GoType}}(GetString({{ .Obj | default "o" }}, {{.Key}}))
	{{- else if eq .Type "BasicBool" }}
		{{.GoType}}(GetBool({{ .Obj | default "o" }}, {{.Key}}))
	{{- else if eq .Type "BasicInt" }}
		GetInt[{{.GoType}}]({{ .Obj | default "o" }}, {{.Key}})
	{{- else if eq .Type "BasicFloat" }}
		GetFloat[{{.GoType}}]({{ .Obj | default "o" }}, {{.Key}})
	{{- else }}
		// unknown basic type {{.Name}} {{.KeyType.Type}} {{.KeyType.GoType}}
	{{- end }}
{{- end }}

{{- define "GenSetBasic" }}
	o.Set("{{.JsonName}}", obj.{{.Name}})
{{- end }}

{{- define "GenGetBasicVar" }}
	{{- $context := dict "Type" .Type "GoType" .GoType "Key" (quote .JsonName) }}
	obj.{{.Name}} = {{ include "GenGetBasic" $context | trim -}}
{{- end }}

{{- define "GenGetPackageObject" }}
	{{- /* package types that aren't basic types need to call the getter for that type */}}
	{{- if eq .JsonName "" }}
		obj.{{.Name}} = Get{{.TypeName}}(o)
	{{- else }}
		{{- if .Pointer }}
			{{ .JsonName }}Val := o.Get("{{.JsonName}}")
			if !{{ .JsonName }}Val.IsUndefined() {
				{{ .JsonName }} := Get{{.ValueType.TypeName}}({{ .JsonName }}Val)
				obj.{{.Name}} = &{{ .JsonName }}
			}
		{{- else }}
			obj.{{.Name}} = Get{{.TypeName}}(o.Get("{{.JsonName}}"))
		{{- end }}
	{{- end }}
{{- end }}

{{- define "GenSetPackageObject" }}
	{{- if eq .JsonName "" }}
		Set{{.TypeName}}(o, &obj.{{.Name}})
	{{- else }}
		o.Set("{{.JsonName}}", map[string]any{})
		{{- if .Pointer }}
		Set{{.TypeName}}(o.Get("{{.JsonName}}"), obj.{{.Name}})
		{{- else }}
		Set{{.TypeName}}(o.Get("{{.JsonName}}"), &obj.{{.Name}})
		{{- end }}
	{{- end }}
{{- end }}

{{- define "GenGetPackageSlice" }}
	{{- /* package slices come as slices to pointers or just slices or sometimes slices to slices... ugh */}}
	{{- if eq .ValueType.Type "Slice" }}
		{{- /* slice slice */}}
		obj.{{.Name}} = GetSliceSlice(o.Get("{{.JsonName}}"), Get{{.ValueType.TypeName}})
	{{- else }}
		{{- if .ValueType.Pointer }}
			{{.JsonName}} := GetSlice(o.Get("{{.JsonName}}"), Get{{.ValueType.TypeName}})
			obj.{{.Name}} = make([]{{.ValueType.GoType}}, len({{.JsonName}}))
			for i := range {{.JsonName}} {
				obj.{{.Name}}[i] = &{{.JsonName}}[i]
			}
		{{- else }}
			obj.{{.Name}} = GetSlice(o.Get("{{.JsonName}}"), Get{{.ValueType.TypeName}})
		{{- end }}
	{{- end }}
{{- end }}

{{- define "GenSetPackageSlice" }}
	{{- /* package slices come as slices to pointers or just slices or sometimes slices to slices... ugh */}}
	{{- if eq .ValueType.Type "Slice" }}
		{{- /* slice slice */}}
		o.Set("{{.JsonName}}", []any{})
		SetSliceSlice(o.Get("{{.JsonName}}"), obj.{{.Name}}, Set{{.ValueType.TypeName}})
	{{- else }}
		o.Set("{{.JsonName}}", []any{})
		{{- if .ValueType.Pointer }}
			SetPointerSlice(o.Get("{{.JsonName}}"), obj.{{.Name}}, Set{{.ValueType.TypeName}})
		{{- else }}
			SetSlice(o.Get("{{.JsonName}}"), obj.{{.Name}}, Set{{.ValueType.TypeName}})
		{{- end }}
	{{- end }}
{{- end }}

{{- define "GenGetArray" }}
	{{- if eq .ValueType.Type "BasicInt" }}
		if !o.Get("{{.JsonName}}").IsUndefined() && o.Get("{{.JsonName}}").Length() != 0 {
			obj.{{.Name}} = [{{.ArrayLength}}]{{.ValueType.GoType}}(GetIntArray[{{.ValueType.GoType}}](o, "{{.JsonName}}"))
		}
	{{- else }}
		unknown type {{.Name}} {{.GoType}}
	{{- end }}
{{- end }}

{{- define "GenGetMap" }}
	{{- /* maps are weird. We have to get the Object.Keys from the js object, then set each key as a type */}}
	{{.JsonName}}Obj := o.Get("{{.JsonName}}")
	if !{{.JsonName}}Obj.IsUndefined() {
		{{.JsonName}} := make(map[{{.KeyType.GoType}}]{{.ValueType.GoType}})
		{{.JsonName}}Keys := js.Global().Get("Object").Call("keys", {{.JsonName}}Obj)
		for i := 0; i < {{.JsonName}}Keys.Length(); i++ {
		{{- if eq .KeyType.Type "BasicString" }}
			key := {{.KeyType.GoType}}({{.JsonName}}Keys.Index(i).String())
		{{- else if eq .KeyType.Type "BasicInt" }}
			key, _ := strconv.Atoi({{.JsonName}}Keys.Index(i).String())
		{{- else if eq .KeyType.Type "Named" }}
			key := {{.KeyType.GoType}}({{.JsonName}}Keys.Index(i).String())
		{{- else }}
			// unknown key type {{.Name}} {{.KeyType.Type}} {{.KeyType.GoType}}
		{{- end }}
		{{- if .ValueType.IsBasic }}
			{{- $key := printf "%sObj" .JsonName }}
			{{- $context := dict "Type" .ValueType.Type "GoType" .ValueType.GoType "Key" "fmt.Sprintf(\"%v\", key)" "Obj" $key }}
			{{.JsonName}}[key] = {{ include "GenGetBasic" $context | trim -}}
		{{- else }}
			// unknown type {{.Name}} {{.ValueType.Type}} {{.ValueType.GoType}}
		{{- end }}
		}
		obj.{{.Name}} = {{.JsonName}}
	}
{{- end }}

{{- define "GenSetMap" }}
	{{- /* setting maps is easier, just create a new object and set each key */}}
	{{.JsonName}}Map := js.ValueOf(map[string]any{})
	for key, value := range obj.{{.Name}} {
	{{- if .ValueType.IsBasic }}
		{{.JsonName}}Map.Set(fmt.Sprintf("%v", key), {{.ValueType.GoType}}(value))
	{{- end }}
	}
	o.Set("{{.JsonName}}", {{.JsonName}}Map)
{{- end }}

{{- define "GenGetNamedType" }}
	{{- if eq .UnderlyingType.GoType "string" }}
		obj.{{.Name}} = {{.GoType}}(GetString(o, "{{.JsonName}}"))
	{{- else if eq .UnderlyingType.GoType "int" }}
		obj.{{.Name}} = {{.GoType}}(GetInt[{{.GoType}}](o, "{{.JsonName}}"))
	{{- else if eq .UnderlyingType.GoType "uint32" }}
		obj.{{.Name}} = {{.GoType}}(GetInt[{{.GoType}}](o, "{{.JsonName}}"))
	{{- else }}
		// unknown type {{.Name}} {{.GoType}} {{.UnderlyingType.GoType}}
	{{- end }}
{{- end }}

{{- define "GenSetNamedType" }}
	{{- if .UnderlyingType.IsBasic }}
		o.Set("{{.JsonName}}", {{.UnderlyingType.GoType}}(obj.{{.Name}}))
	{{- else }}
		// unknown type {{.Name}} {{.GoType}} {{.UnderlyingType.GoType}}
	{{- end }}
{{- end }}

{{- define "GenGetOtherType" }}
	{{- if eq .FullType "time.Time" }}
		obj.{{.Name}}, _ = GetTime(o, "{{.JsonName}}")
	{{- else }}
		unknown type {{.Name}} {{.GoType}}
	{{- end }}
{{- end }}

{{- define "GenSetOtherType" }}
	{{- if eq .FullType "time.Time" }}
		SetTime(o, "{{.JsonName}}", obj.{{.Name}})
	{{- else }}
		unknown type {{.Name}} {{.GoType}}
	{{- end }}
{{- end }}

{{- /* Create Get functions for each of our serializer types */}}
{{- range .Serializers}}

func Get{{.Name}}(o js.Value) {{$.Pkg}}.{{.Name}} {
	obj := {{$.Pkg}}.{{.Name}}{}
	{{- range .Fields}}
		{{- if .Ignore }}
			{{- if .Exported }}
				// {{.Name}} {{.JsonName}} {{ .Type }} ignored
			{{- end }}
			{{- continue }}
		{{- end }}
	
		{{- /* package types that aren't basic types need to call the getter for that type */}}
		{{- if .Type.IsBasic }}
			{{- include "GenGetBasicVar" . | trim | nindent 4 -}}
		{{- else if eq .Type "Object" }}
			{{- include "GenGetPackageObject" . | trim | nindent 4 -}}
		{{- else if eq .Type "Named" }}
			{{- include "GenGetNamedType" . | trim | nindent 4 -}}
		{{- else if eq .Type "Slice" }}
			{{- include "GenGetPackageSlice" . | trim | nindent 4 -}}
		{{- else if eq .Type "Array" }}
			{{- include "GenGetArray" . | trim | nindent 4 -}}
		{{- else if eq .Type "Map" }}
			{{- include "GenGetMap" . | nindent 2 -}}
		{{- else  }}
			{{- include "GenGetOtherType" . | trim | nindent 4 -}}
		{{- end }}
	{{- end }}
	return obj
}

func Set{{.Name}}(o js.Value, obj *{{$.Pkg}}.{{.Name}}) {
	{{- range .Fields}}	
		{{- if .Ignore }}
			{{- if .Exported }}
				// {{.Name}} {{.JsonName}} {{ .Type }} ignored
			{{- end }}
			{{- continue }}
		{{- end }}
		{{- /* package types that aren't basic types need to call the getter for that type */}}
		{{- if .Type.IsBasic }}		
			{{- include "GenSetBasic" . | trim | nindent 4 -}}
		{{- else if eq .Type "Object" }}
			{{- include "GenSetPackageObject" . | trim | nindent 4 -}}
		{{- else if eq .Type "Named" }}
			{{- include "GenSetNamedType" . | trim | nindent 4 -}}
		{{- else if eq .Type "Slice" }}
			{{- include "GenSetPackageSlice" . | trim | nindent 4 -}}
		{{- else if eq .Type "Array" }}
				// {{.Name}} {{.JsonName}} {{ .Type }} ignored
		{{- else if eq .Type "Map" }}
			{{- include "GenSetMap" . | trim | nindent 4 -}}
		{{- else  }}
			{{- include "GenSetOtherType" . | trim | nindent 4 -}}
		{{- end }}
	{{- end }}
}
{{- end}}


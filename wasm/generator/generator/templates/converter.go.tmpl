//go:build wasi || wasm

package wasm

import (
	"fmt"
	"syscall/js"
	"time"

	"github.com/sirgwain/craig-stars/cs"
)

func getPointer[T any](val T) *T {
	return &val
}

func getInt[T ~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64 | ~int | ~int8 | ~int16 | ~int32 | ~int64](o js.Value) T {
	if o.IsUndefined() {
		return 0
	}

	return T(o.Int())
}

func getFloat[T ~float32 | ~float64](o js.Value) T {
	if o.IsUndefined() {
		return 0
	}

	return T(o.Float())
}

func getBool(o js.Value) bool {
	if o.IsUndefined() {
		return false
	}
	return o.Bool()
}

func getString(o js.Value) string {
	if o.IsUndefined() {
		return ""
	}
	return o.String()
}

func getTime(o js.Value) time.Time {
	var result time.Time
	if o.IsUndefined() || o.IsNull() {
		return result
	}
	// time assumes json string has quotes
	result.UnmarshalJSON([]byte("\"" + o.String() + "\""))
	return result
}

func SetTime(o js.Value, key string, time time.Time) {
    json, _ := time.MarshalJSON()
    o.Set(key, string(json))
}

// GetSlice populates an array with a getter function
func GetSlice[T any](o js.Value, getter func(o js.Value) T) []T {
	if o.IsUndefined() || o.IsNull() {
		return nil
	}

	items := make([]T, o.Length())
	for i := 0; i < len(items); i++ {
		items[i] = getter(o.Index(i))
	}
	return items
}

// SetSlice sets a jsarray with items using a setter function
func SetSlice[T any](o js.Value, items []T, setter func(o js.Value, item *T)) {

	for i := 0; i < len(items); i++ {
        oItem := js.ValueOf(map[string]any{})
        setter(oItem, &items[i])
		o.SetIndex(i, oItem)
	}
}

// GetSlice populates an array with a getter function
func GetPointerSlice[T any](o js.Value, getter func(o js.Value) T) []*T {
	if o.IsUndefined() || o.IsNull() {
		return nil
	}

	items := make([]*T, o.Length())
	for i := 0; i < len(items); i++ {
		items[i] = getPointer(getter(o.Index(i)))
	}
	return items
}

// SetPointerSlice sets a jsarray with pointer items using a setter function
func SetPointerSlice[T any](o js.Value, items []*T, setter func(o js.Value, item *T)) {

	for i := 0; i < len(items); i++ {
		oItem := js.ValueOf(map[string]any{})
		setter(oItem, items[i])
		o.SetIndex(i, oItem)
	}
}

// GetSliceSlice populates a 2d array
func GetSliceSlice[T any](o js.Value, getter func(o js.Value) T) [][]T {
	if o.IsUndefined() || o.IsNull() {
		return nil
	}

	items := make([][]T, o.Length())
	for i := 0; i < len(items); i++ {
		items[i] = GetSlice(o.Index(i), getter)
	}
	return items
}

// SetSliceSlice sets a 2d jsarray with items using a setter function
func SetSliceSlice[T any](o js.Value, items [][]T, setter func(o js.Value, item *T)) {

	for i := 0; i < len(items); i++ {
		oItem := js.ValueOf([]any{})
		SetSlice(oItem, items[i], setter)
		o.SetIndex(i, oItem)
	}
}

func GetMap[M ~map[K]V, K comparable, V any](o js.Value, keyGetter func(o js.Value) K, valueGetter func(o js.Value) V) M {
	result := make(M)
	if !o.IsUndefined() {
		resultKeys := js.Global().Get("Object").Call("keys", o)
		for i := 0; i < resultKeys.Length(); i++ {
			key := keyGetter(o)
			result[key] = valueGetter(o.Get(fmt.Sprintf("%v", key)))
		}
	}
	return result
}


{{- /* 
	Render a function like 

	getInt[int](o.Get("grav")) 
*/}}
{{- define "GetBasicGetter" }}
	{{- $type := .type }}
	{{- if eq $type.Type "BasicString" }}
		getString
	{{- else if eq $type.Type "BasicBool" }}
		getBool
	{{- else if eq $type.Type "BasicInt" }}
		getInt
	{{- else if eq $type.Type "BasicFloat" }}
		getFloat
	{{- else }}
		unknownbasictype
	{{- end }}
{{- end }}

{{- /* 
	Render a function like 

	getInt[int](o.Get("grav")) 
*/}}
{{- define "GetBasicValue" }}
	{{- $type := .type }}
	{{- $goType := default $type.GoType .goType }}
	{{- $jsObj := default "o" .jsObj }}
	{{- if eq $type.Type "BasicString" }}
		{{- if ne $goType .TypeName }}
			{{$goType}}(getString({{$jsObj}}))
		{{- else }}
			getString({{$jsObj}})
		{{- end }}
	{{- else if eq $type.Type "BasicBool" }}
		getBool({{$jsObj}})
	{{- else if eq $type.Type "BasicInt" }}
		getInt[{{$goType}}]({{$jsObj}})
	{{- else if eq $type.Type "BasicFloat" }}
		getFloat[{{$goType}}]({{$jsObj}})
	{{- else }}
		unknownbasictype
	{{- end }}
{{- end }}

{{- define "GetSliceValue" }}
	{{- $type := .type }}
	{{- $valueType := $type.ValueType }}
	{{- $jsObj := default "o" .jsObj}}

	{{- if $valueType.Package }}
		{{- /* package slices come as slices to pointers or just slices or sometimes slices to slices... ugh */}}
		{{- if eq $valueType.Type "Slice" }}
			{{- /* slice slice */}}
			GetSliceSlice({{$jsObj}}, Get{{$valueType.TypeName}})
		{{- else if eq $valueType.Type "Object" }}
			{{- if $valueType.Pointer }}
				GetPointerSlice({{$jsObj}}, Get{{$valueType.TypeName}})
			{{- else }}
				GetSlice({{$jsObj}}, Get{{$valueType.TypeName}})
			{{- end }}
		{{- else if eq $valueType.Type "Named" }}
			GetSlice[{{$valueType.GoType}}]({{$jsObj}}, Get{{$valueType.TypeName}})
		{{- else }}
			unknonwnslicetype_{{$valueType.TypeName}}_{{$valueType.GoType}}_{{$valueType.Type}}
		{{- end }}
	{{- else }}
		{{- if $valueType.IsBasic }}
			GetSlice[{{$valueType.GoType}}]({{$jsObj}}, {{ include "GetBasicGetter" (dict "type" $valueType) | trim}})
		{{- end }}
	{{- end }}
{{- end }}

{{- define "GetMapValue" }}
	{{- $type := .type }}
	{{- $keyType := default $type.KeyType .keyType }}
	{{- $valueType := default $type.ValueType .valueType }}
	{{- $jsObj := default "o" .jsObj}}
	{{- $valueGetter := printf "Get%s" $valueType.TypeName }}
	{{- $keyGetter := printf "Get%s" $keyType.TypeName }}

	{{- if $keyType.IsBasic }}
		{{- $keyGetter = include "GetBasicGetter" (dict "type" $keyType) | trim}}
	{{- end }}
	{{- if $valueType.IsBasic }}
		{{- $valueGetter = include "GetBasicGetter" (dict "type" $valueType) | trim }}
	{{- end }}

	{{- if $valueType.Pointer }}
		{{- $valueGetter = printf "func(o js.Value) %s { return getPointer(%s(o)) }" $valueType.GoType $valueGetter }}
	{{- end }}

	GetMap[{{$type.GoType}}, {{$keyType.GoType}}, {{$valueType.GoType}}]({{$jsObj}}, {{$keyGetter}}, {{$valueGetter}})
{{- end }}

{{- /* 
	Render a function like 

	getInt[int](o.Get("grav")) 
	or 
	GetHab(o.Get("habLow")) 
*/}}
{{- define "GetValue" }}
	{{- $type := .type }}
	{{- $jsObj := default "o" .jsObj}}
	{{- if $type.IsBasic }}
		{{ include "GetBasicValue" . }}
	{{- else if eq $type.Type "Object" }}
		{{- if $type.Pointer }}
			getPointer(Get{{$type.TypeName}}({{$jsObj}}))
		{{- else }}
			Get{{$type.TypeName}}({{$jsObj}})
		{{- end }}
	{{- else if eq $type.Type "Slice" }}
		{{ include "GetSliceValue" . }}
	{{- else if eq $type.Type "Array" }}
		{{$type.GoType}}({{- include "GetSliceValue" . | trim}})
	{{- else if eq $type.Type "Map" }}
		{{ include "GetMapValue" . }}
	{{- else if eq $type.Type "Named" }}
		Get{{$type.TypeName}}({{$jsObj}})
	{{- else if eq $type.FullType "time.Time" }}
		getTime({{$jsObj}})
	{{- else  }}
		unknown // {{$type.GoType}}
	{{- end }}
{{- end }}

{{- /* Create Get functions for each of our serializer types */}}
{{- range .Serializers}}

func Get{{.Name}}(o js.Value) {{$.Pkg}}.{{.Name}} {
	var obj {{$.Pkg}}.{{.Name}}
	if o.IsUndefined() {
		return obj
	}
	{{- if eq .Type.Type "Object" }}
		{{- range .Fields}}
			{{- if .Ignore }}
				{{- if and .Exported (ne .JsonName "") }}
					// {{.Name}} {{.JsonName}} {{ .Type }} ignored
				{{- end }}
				{{- continue }}
			{{- end }}
		
			{{- /* for the js object, we do something like o.Get("habLow") for the jsObj */}}
			{{- $jsObj := "o" }}
			{{- if ne .JsonName "" }}
				{{- $jsObj = printf "o.Get(\"%s\")" .JsonName }}
			{{- end }}
			
			{{- /* the GetValue function expects two args, a type and a jsObj */}}
			{{- $context := dict "type" .FieldType "jsObj" $jsObj}}				
			obj.{{.Name}} = {{ include "GetValue" $context | trim }}
		{{- end }}
	{{- else if eq .Type.Type "Named" }}
		{{- if .Type.UnderlyingType.IsBasic }}
			{{- $context := dict "type" .Type.UnderlyingType "goType" .Type.GoType }}
			obj = {{ include "GetBasicValue" $context | trim }}
		{{- else if eq .Type.UnderlyingType.Type "Map" }}
			{{- $context := dict "type" .Type.UnderlyingType "goType" .Type.GoType }}
			obj = {{ include "GetMapValue" $context | trim }}
		{{- else }}
			// unknown named underlying type {{.Type.UnderlyingType.GoType}} {{.Type.UnderlyingType.Type}}
		{{- end }}
	{{- end }}
	return obj
}

func Set{{.Name}}(o js.Value, obj *{{$.Pkg}}.{{.Name}}) {
	{{- range .Fields}}	
		{{- if .Ignore }}
			{{- if .Exported }}
				// {{.Name}} {{.JsonName}} {{ .Type }} ignored
			{{- end }}
			{{- continue }}
		{{- end }}
	{{- end }}
}

{{- end}}

